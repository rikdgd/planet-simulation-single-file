<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Simulation</title>
    <script>
        class Planet {
            constructor(id, x, y, mass, xVel, yVel) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.mass = mass;
                this.xVel = xVel;
                this.yVel = yVel;
            }
            
            getRadius() {
                return Math.pow(this.mass / ((4*Math.PI) / 3), 1/3);
            }
        }
        
        // Calculates distance from planet A to planet B
        function calculateDistance(planetA, planetB) {
            let distance = Math.sqrt((planetB.x - planetA.x)**2 + (planetB.y - planetA.y)**2);
            if (distance < 0) distance = distance * -1;
            return distance;
        }
        
        // Calculates the force of gravity acted upon planet A by planet B.
        function calculateForceGravity(planetA, planetB) {
            const massSquared = planetA.mass * planetB.mass;
            const distance = calculateDistance(planetA, planetB);
            return massSquared / distance**2;
        }
        
        // Calculates the acceleration of planet A due to planet B
        function calculateXYAcceleration(planetA, planetB) {
            const xDistance = planetB.x - planetA.x;
            const yDistance = planetB.y - planetA.y;
            const forceGravity = calculateForceGravity(planetA, planetB);
            
            const xAcceleration = (forceGravity * xDistance) * 0.000000067 * planetB.mass;
            const yAcceleration = (forceGravity * yDistance) * 0.000000067 * planetB.mass;
            return [xAcceleration, yAcceleration];
        }
        
        // The returned planet will have the id of planet A
        function mergePlanets(planetA, planetB) {
            const newMass = planetA.mass + planetB.mass;
            const sumMomentumX = planetA.mass * planetA.xVel + planetB.mass * planetB.xVel;
            const sumMomentumY = planetA.mass * planetA.yVel + planetB.mass * planetB.yVel;
            const newXVel = sumMomentumX / newMass;
            const newYVel = sumMomentumY / newMass;
            const centerOfMassX = (planetA.mass * planetA.x + planetB.mass * planetB.x) / newMass;
            const centerOfMassY = (planetA.mass * planetA.y + planetB.mass * planetB.y) / newMass;
            
            return new Planet(
                planetA.id,
                centerOfMassX,
                centerOfMassY,
                newMass,
                newXVel,
                newYVel
            );
        }
        
        function calculateCenterOfMass(planetList) {
            let totalMass = 0;
            let centerOfMassX = 0;
            let centerOfMassY = 0;
            
            planetList.forEach(planet => {
                totalMass = totalMass + planet.mass;
                centerOfMassX = centerOfMassX + planet.mass * planet.x;
                centerOfMassY = centerOfMassY + planet.mass * planet.y;
            });
            
            centerOfMassX = centerOfMassX / totalMass;
            centerOfMassY = centerOfMassY / totalMass;
            
            return [centerOfMassX, centerOfMassY];
        }
        
        function generatePlanetList(amount, mass, bigPlanet, randomMovement) {
            const canvas = document.getElementById("planetCanvas");
            let planetList = [];
            
            if (bigPlanet) {
                const newPlanet = new Planet(
                    0,
                    canvas.width / 2,
                    canvas.height / 2,
                    mass * 10,
                    0,
                    0
                )
                
                planetList.push(newPlanet);
            }
            
            for (let i = 1; i <= amount; i++) {
                const newPlanet = new Planet(
                    i,
                    getRandomInt(canvas.width),
                    getRandomInt(canvas.height),
                    mass,
                    0,
                    0
                )
                
                if (randomMovement) {
                    newPlanet.xVel = Math.random() * 0.04 - 0.02;
                    newPlanet.yVel = Math.random() * 0.04 - 0.02;
                }
                
                planetList.push(newPlanet);
            }
            
            return planetList;
        }
        
        function getPlanetWithBiggestMass(planetList, index = 0) {
            let biggestPlanet = planetList[0];
            planetList.forEach(planet => {
                if (planet.mass > biggestPlanet.mass) {
                    biggestPlanet = planet;
                }
            });
            
            return biggestPlanet;
        }
        
        function drawPlanet(planet) {
            const canvas = document.getElementById("planetCanvas");
            const ctx = canvas.getContext("2d");
            
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, planet.getRadius(), 0, 2 * Math.PI);
            
            ctx.fillStyle = "white";
            ctx.fill();
        }
        
        function clearCanvas(x, y) {
            const canvas = document.getElementById("planetCanvas");
            const ctx = canvas.getContext("2d");
            const currentTranslation = ctx.getTransform();
            
            ctx.fillStyle = "black";
            ctx.fillRect(x, y, canvas.width, canvas.height);
        }
        
        function translateCanvasToCenterPoint(canvas, x, y) {
            const ctx = canvas.getContext("2d");
            const currentTranslation = ctx.getTransform();
        
            // Reset the transformation matrix
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            const translationX = canvas.width / 2 - x;
            const translationY = canvas.height / 2 - y;
            
            ctx.translate(translationX, translationY);
        }
        
        function translatePlanetCanvas(canvas, x, y) {
            translateCanvasToCenterPoint(canvas, x, y);
            clearCanvas(
                x - canvas.width / 2, 
                y - canvas.height / 2
            );
        }
        
        function getSimulationConfig() {
            try {
                const planetCount = Number(document.getElementById("planetCount").value);
                let planetMass = Number(document.getElementById("planetMass").value);
                const centralPlanet = Boolean(document.getElementById("centralPlanet").checked);
                const startingMovement = Boolean(document.getElementById("startingMovement").checked);
                let focusCenterOfMass = Boolean(document.getElementById("focusCenterOfMass").checked);
                let focusBiggestMass = Boolean(document.getElementById("focusBiggestMass").checked);
                
                if (planetMass <= 0) planetMass = 5;
                
                if (focusCenterOfMass && focusBiggestMass) {
                    alert('You cannot focus on both the center of mass and the biggest mass at the same time!');
                    focusCenterOfMass = false;
                    focusBiggestMass = false;
                }
                
                return {
                    planetCount: planetCount,
                    planetMass: planetMass,
                    centralPlanet: centralPlanet,
                    startingMovement: startingMovement,
                    focusCenterOfMass: focusCenterOfMass,
                    focusBiggestMass: focusBiggestMass
                };
            } catch {
                alert("The provided input was incorrect.");
                return null;
            }
        }
        
        function getRandomInt(max) {
            return Math.round(Math.random() * max);
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function updatePlanetList(planetList) {
            let newPlanetList = [];
            let removedPlanetsIdList = [];
            
            for (let mainPlanetIndex = 0; mainPlanetIndex < planetList.length; mainPlanetIndex++) {
                let mainPlanet = planetList[mainPlanetIndex];
                if (removedPlanetsIdList.includes(mainPlanet.id)) continue;
                
                for (let otherPlanetIndex = 0; otherPlanetIndex < planetList.length; otherPlanetIndex++) {
                    const otherPlanet = planetList[otherPlanetIndex];
                    if (mainPlanet.id == otherPlanet.id || removedPlanetsIdList.includes(otherPlanet.id)) {
                        continue;
                    } else {
                        // We arrive here when we compare two seperate valid planets.
                        const radiusSum = mainPlanet.getRadius() + otherPlanet.getRadius();
                        const distance = calculateDistance(mainPlanet, otherPlanet);
                        
                        // Check if the planets need to be merged.
                        if (distance < radiusSum) {
                            mainPlanet = mergePlanets(mainPlanet, otherPlanet);
                            removedPlanetsIdList.push(otherPlanet.id);
                        } else {
                            const [xAcc, yAcc] = calculateXYAcceleration(mainPlanet, otherPlanet);
                            mainPlanet.xVel = mainPlanet.xVel + xAcc;
                            mainPlanet.yVel = mainPlanet.yVel + yAcc;
                        }
                        
                        mainPlanet.x = mainPlanet.x + mainPlanet.xVel;
                        mainPlanet.y = mainPlanet.y + mainPlanet.yVel;
                    }
                }
                
                newPlanetList.push(mainPlanet);
            }
            
            return newPlanetList;
        }
        
        async function startSimulation() {
            const config = getSimulationConfig();
            if (!config) {
                alert("Could not start simulation, your input is incorrect.");
                return;
            }
            
            const frameTime = 34;   // a value of 34 results in almost 30 Hertz.
            const canvas = document.getElementById("planetCanvas");
            let planetList = generatePlanetList(
                config.planetCount, 
                config.planetMass, 
                config.centralPlanet, 
                config.startingMovement
            );
            
            
            let running = true;
            while(running) {
                const startTime = performance.now();
                
                if (config.focusCenterOfMass) {
                    const [centerOfMassX, centerOfMassY] = calculateCenterOfMass(planetList);
                    // translateCanvasToCenterPoint(canvas, centerOfMassX, centerOfMassY);
                    // clearCanvas(centerOfMassX - canvas.width / 2, centerOfMassY - canvas.height / 2);
                    translatePlanetCanvas(canvas, centerOfMassX, centerOfMassY);
                } else if (config.focusBiggestMass) {
                    const biggestMass = getPlanetWithBiggestMass(planetList);
                    const [biggestMassX, biggestMassY] = [biggestMass.x, biggestMass.y];
                    console.log(biggestMass);
                    translatePlanetCanvas(canvas, biggestMassX, biggestMassY);
                } else {
                    clearCanvas(0, 0);
                }
                
                const newPlanetList = updatePlanetList(planetList);
                planetList = newPlanetList;
                
                planetList.forEach(planet => {
                    drawPlanet(planet);
                });
                
                if (planetList.length == 1) {
                    running = false;
                    alert('simulation ended.');
                }
                
                const endTime = performance.now();
                if (endTime - startTime < frameTime) {
                    await sleep(frameTime - (endTime - startTime));
                }
            }
        }
    </script>
    <style>
        body {
            background-color: rgb(78, 75, 90);
            padding-left: 5%;
            padding-right: 5%;
        }
        
        h1 {
            color: rgb(234, 231, 247);
        }
        
        label {
            color: rgb(234, 231, 247);
        }
        
        #planetCanvas {
            border: 1px solid rgb(234, 231, 247);
            border-radius: 10px;
        }
        
        .container {
            display: block;
        }
        
        .simulationConfig {
            background-color: rgb(49, 45, 63);
            border-radius: 10px;
            margin: 6px;
            padding: 16px;
            
            position: fixed;
            top: 2%;
            left: auto;
            right: 5%;
            bottom: auto;
            gap: 14px;
            
            display: flex;
            flex-direction: column;
            max-width: 300px;
        }
        
        .divider {
            width: auto;
            height: 20px;
        }
    </style>
</head>
<body>
    <h1>Planet Simulation</h1>
    <div class="container">
        <canvas id="planetCanvas" width="1200" height="800"></canvas>
        
        <div class="simulationConfig">
            <label for="planetCount">Planet count:</label>
            <input id="planetCount" type="number"/>
            <div class="divider"></div>
            
            <label for="planetMass">Enter a starting mass for the planets:</label>
            <input id="planetMass" type="number" placeholder="5"/>
            <div class="divider"></div>
            
            <label for="startingMovement">Whether or not to the planets start with random movement.</label>
            <input id="startingMovement" type="checkbox"/>
            <div class="divider"></div>
            
            <label for="centralPlanet">Start with big planet in center. This adds an additional new planet.</label>
            <input id="centralPlanet" type="checkbox"/>
            <div class="divider"></div>
            
            <label for="focusCenterOfMass">Keep the camera focussed on the center of mass.</label>
            <input id="focusCenterOfMass" type="checkbox"/>
            <div class="divider"></div>
            
            <label for="focusBiggestMass">Keep the camera focussed on the planet with the highest mass. Centers the first if they are the same.</label>
            <input id="focusBiggestMass" type="checkbox" checked/>
            <div class="divider"></div>
            
            <button onclick="startSimulation()">Start simulation!</button>
        </div>
    </div>
</body>
</html>
